{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Throttling","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This package offers a robust rate-limiting module designed specifically for Ellar,  providing efficient throttling capabilities for web applications.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the Ellar Throttler package, use pip within your virtual environment:</p> <pre><code>$(venv) pip install ellar-throttler\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#throttlermodule","title":"ThrottlerModule","text":"<p>The <code>ThrottlerModule</code> serves as the primary interface for configuring throttling mechanisms across the entire Ellar application.</p>"},{"location":"#throttlermodule-parameters","title":"ThrottlerModule Parameters","text":"Parameter Description throttlers A list of <code>IThrottleModel</code> instances defining various throttling mechanisms. storage An <code>IThrottlerStorage</code> service, instance, or class responsible for tracking throttling. error_message A customizable string to replace the default throttler error message. ignore_user_agents An array of user-agent strings to exempt from throttling. skip_if A global function that evaluates <code>ExecutionContext</code> and returns a boolean to bypass throttler logic."},{"location":"#throttlermodule-setup","title":"ThrottlerModule Setup","text":"<p>Similar to other Ellar modules, you can set up <code>ThrottlerModule</code> directly using the <code>setup</code> function or configure it via <code>register_setup</code>.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # Allow 100 requests per 5 minutes for anonymous users\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # Allow 2000 requests per day for authenticated users\n        ]\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>In the above setup, we've specified a limit of 100 requests per 5 minutes for anonymous users and 2000 requests per day for authenticated users.</p> <p>Alternatively, configuration-based setup is demonstrated below:</p> config.py<pre><code>...\nfrom ellar_throttler import AnonymousThrottler, UserThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # Allow 100 requests per 5 minutes for anonymous users\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # Allow 2000 requests per day for authenticated users\n        ]\n    }\n</code></pre> <p>Then, in <code>ApplicationModule</code>:</p> <pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule\n\n@Module(modules=[\n    ThrottlerModule.register_setup()\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"#throttle-all-routes","title":"Throttle All Routes","text":"<p>To apply throttling to all incoming requests, utilize <code>ThrottlerInterceptor</code> globally, as illustrated below:</p> <pre><code>from ellar.app import AppFactory\nfrom ellar_throttler import ThrottlerInterceptor\nfrom .module import AppModule\n\napp = AppFactory.create_from_app_module(AppModule)\napp.use_global_interceptors(ThrottlerInterceptor)\n</code></pre>"},{"location":"#decorators","title":"Decorators","text":"<p>This package introduces two decorators, <code>Throttle</code> and <code>SkipThrottle</code>,  designed to provide additional metadata for the <code>ThrottlerInterceptor</code>, guiding its throttling behavior or  bypassing it for decorated controllers or route functions.</p>"},{"location":"#using-throttle-decorator","title":"Using <code>Throttle</code> Decorator","text":"<p>The <code>Throttle</code> decorator applies the <code>ThrottlerInterceptor</code> and allows for overriding  configurations for any throttler model defined in the <code>ThrottlerModule.throttlers</code> list.</p> controllers.py<pre><code>from ellar_throttler import Throttle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@Throttle(apply_interceptor=True)\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>In the above example, by setting <code>apply_interceptor=True</code> within @Throttle,  the <code>ThrottlerInterceptor</code> is applied to all routes within the <code>LimitController</code>.  This feature is particularly useful when <code>ThrottlerInterceptor</code> is not globally applied.</p> <p>Additionally, the @Throttle decorator can be used on a route level:</p> <pre><code>@get()\n@Throttle(apply_interceptor=True)\ndef get_throttled(self, use_auth: bool):\n    return self.app_service.success(use_auth)\n</code></pre> <p>Another application of the @Throttle decorator is to override <code>ttl</code> and <code>limit</code> for a specific configured throttler model:</p> <pre><code>@Controller(\"/limit\")\n@Throttle(apply_interceptor=True, anon={'ttl': 100, 'limit': 30})\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>In this scenario, different <code>ttl</code> and <code>limit</code> values are applied to the LimitController  when executing against a throttler model named <code>anon</code>.</p>"},{"location":"#using-skipthrottle-decorator","title":"Using <code>SkipThrottle</code> Decorator","text":"<p>The <code>SkipThrottle</code> decorator marks a decorated class or route function with metadata  used by <code>ThrottlerInterceptor</code> to entirely bypass throttling or selectively skip specific throttler models.</p> <p>For instance, if using <code>ThrottlerInterceptor</code> as a global interceptor and wishing to bypass throttling for <code>LimitController</code>:</p> <pre><code>from ellar_throttler import SkipThrottle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@SkipThrottle()\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>This setup will bypass all throttling models for <code>LimitController</code>. If only the <code>user</code> throttler model needs to be skipped:</p> <pre><code>from ellar_throttler import SkipThrottle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@SkipThrottle(user=True)\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>This configuration skips all throttling models except for the one named <code>user</code>.</p>"},{"location":"#ithrottlermodel","title":"IThrottlerModel","text":"<p>The IThrottlerModel serves as an interface for defining attributes and properties specific to a throttler.  The package provides several <code>ThrottlerModel</code> implementations to facilitate usage.</p>"},{"location":"#anonymousthrottler","title":"AnonymousThrottler","text":"<p>The <code>AnonymousThrottler</code> model is designed for throttling unauthenticated users, utilizing their  <code>client.host</code> address as a key for throttling purposes. It exempts authenticated requests and is  ideal for limiting requests from unknown sources.</p> <pre><code>from ellar_throttler import AnonymousThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            # Configuring burst and sustained throttling for unauthenticated users\n            AnonymousThrottler(limit=100, ttl=(60*5), name='burst'),\n            AnonymousThrottler(limit=1000, ttl=(60*60*24), name='sustain'),\n        ]\n    }\n</code></pre>"},{"location":"#userthrottler","title":"UserThrottler","text":"<p>The <code>UserThrottler</code> model is tailored for throttling authenticated users,  utilizing user <code>id</code> or <code>sub</code> to generate a key for throttling. Unauthenticated requests  resort to using the <code>client.host</code> address for generating a unique key. </p> <pre><code>from ellar_throttler import UserThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            # Configuring burst and sustained throttling for authenticated users\n            UserThrottler(limit=100, ttl=(60*5), name='burst'),\n            UserThrottler(limit=1000, ttl=(60*60*24), name='sustain'),\n        ]\n    }\n</code></pre>"},{"location":"#ithrottlerstorage","title":"IThrottlerStorage","text":"<p>The <code>IThrottlerStorage</code> interface defines methods for managing the details of request tracking within the throttler.  This package provides two implementations of <code>IThrottlerStorage</code>:</p>"},{"location":"#throttlerstorageservice","title":"<code>ThrottlerStorageService</code>:","text":"<p>This service offers in-memory storage for throttling, suitable for testing request throttling in development environments.  When configuring <code>ThrottlerModule</code>, if no storage parameter is provided, <code>ThrottlerStorageService</code> is selected by default.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, ThrottlerStorageService\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=200, ttl=(60*24), name='anon'), # 200/day for anonymous requests\n            UserThrottler(limit=1000, ttl=(60*24), name='user'), # 1000/day for authenticated requests\n        ],\n        # storage=ThrottlerStorageService() use as an instance OR\n        storage=ThrottlerStorageService\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"#cachethrottlerstorageservice","title":"<code>CacheThrottlerStorageService</code>","text":"<p>This service utilizes the default caching setup in your Ellar application, providing more dynamic storage options.  It requires setting up caching, where various storage backends are available through  <code>CacheModule</code>.  In the example below, caching is set up using the Redis backend.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar.cache import CacheModule\nfrom ellar.cache.backends.redis import RedisCacheBackend\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, CacheThrottlerStorageService\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # 200/5mins for anonymous requests\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # 2000/24hrs for authenticated requests\n        ],\n        storage=CacheThrottlerStorageService\n    ),\n    CacheModule.setup(default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']))\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>To modify the caching type used in <code>CacheThrottlerStorageService</code>,  you need to extend the class and set the <code>cache_backend</code> to point to the desired caching service backend:</p> <pre><code>from ellar.di import injectable\nfrom ellar.cache import ICacheService\nfrom ellar_throttler import CacheThrottlerStorageService\n\n\n@injectable()\nclass MyNewCacheThrottlerStorageService(CacheThrottlerStorageService):\n    def __init__(self, cache_service: ICacheService) -&gt; None:\n        super().__init__(cache_service)\n        self.cache_backend = 'my_backend'\n\n\n# in root_module.py\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # 200/5mins for anonymous requests\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # 2000/24hrs for authenticated requests\n        ],\n        storage=MyNewCacheThrottlerStorageService\n    ),\n    CacheModule.setup(\n        default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']),\n        my_backend=RedisCacheBackend(servers=['redis://127.0.0.1:6379'])\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"#proxies","title":"Proxies","text":"<p>If you're working with multiple proxies,  you may need to install <code>ProxyHeadersMiddleware</code>.</p>"},{"location":"#working-with-websockets","title":"Working with WebSockets","text":"<p>To utilize WebSockets, you can include <code>WebsocketThrottler</code> in the list of throttlers for your application.</p> <pre><code>from ellar.common import Module\nfrom ellar.cache import CacheModule\nfrom ellar.cache.backends.redis import RedisCacheBackend\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, CacheThrottlerStorageService, model\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            # HTTP Throttling Models\n            AnonymousThrottler(limit=200, ttl=(60*24)), # 200/day for anonymous requests \n            UserThrottler(limit=1000, ttl=(60*24)), # 1000/day for authenticated requests\n            # Websocket Throttling Models\n            model.WebsocketThrottler('ws-burst', limit=200, ttl=(60*24)), # 200/day  \n            model.WebsocketThrottler('ws-sustain', limit=2000, ttl=(60*24)), # 2000/day \n        ],\n        storage=CacheThrottlerStorageService\n    ),\n    CacheModule.setup(default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']))\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>The <code>WebsocketThrottler</code> only runs within the websocket environment.  Additionally, note that <code>WebsocketThrottler</code> workers like <code>UserThrottler</code> for an authenticated  request and <code>AnonymousThrottler</code> for anonymous request.</p>"}]}